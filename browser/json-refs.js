(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.JsonRefs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

// Load promises polyfill if necessary
if (typeof Promise === 'undefined') {
  require('native-promise-only');
}

var _ = require('./lib/utils');
var pathLoader = (typeof window !== "undefined" ? window.PathLoader : typeof global !== "undefined" ? global.PathLoader : null);
var traverse = (typeof window !== "undefined" ? window.traverse : typeof global !== "undefined" ? global.traverse : null);

var remoteCache = {};
var supportedSchemes = ['file', 'http', 'https'];

/**
 * Callback used by all json-refs functions.
 *
 * @param {error} [err] - The error if there is a problem
 * @param {*} [result] - The result of the function
 *
 * @callback resultCallback
 */

/**
 * Callback used to provide access to altering a remote request prior to the request being made.
 *
 * @param {object} req - The Superagent request object
 * @param {string} ref - The reference being resolved (When applicable)
 *
 * @callback prepareRequestCallback
 */

/**
 * Callback used to process the content of a reference.
 *
 * @param {string} content - The content loaded from the file/URL
 * @param {string} ref - The reference string (When applicable)
 * @param {object} [res] - The Superagent response object (For remote URL requests only)
 *
 * @returns {object} The JavaScript object representation of the reference
 *
 * @callback processContentCallback
 */

/* Internal Functions */

/**
 * Retrieves the content at the URL and returns its JSON content.
 *
 * @param {string} url - The URL to retrieve
 * @param {object} options - The options passed to resolveRefs
 *
 * @throws Error if there is a problem making the request or the content is not JSON
 *
 * @returns {Promise} The promise
 */
function getRemoteJson (url, options) {
  var json = remoteCache[url];
  var allTasks = Promise.resolve();
  var scheme = url.indexOf(':') === -1 ? undefined : url.split(':')[0];

  if (!_.isUndefined(json)) {
    allTasks = allTasks.then(function () {
      return json;
    });
  } else if (supportedSchemes.indexOf(scheme) === -1 && !_.isUndefined(scheme)) {
    allTasks = allTasks.then(function () {
      return Promise.reject(new Error('Unsupported remote reference scheme: ' + scheme));
    });
  } else {
    allTasks = pathLoader.load(url, options);

    if (options.processContent) {
      allTasks = allTasks.then(function (content) {
        return options.processContent(content, url);
      });
    } else {
      allTasks = allTasks.then(JSON.parse);
    }

    allTasks.then(function (nJson) {
      remoteCache[url] = nJson;

      return nJson;
    });
  }

  return allTasks;
}

/* Exported Functions */

/**
 * Clears the internal cache of url -> JavaScript object mappings based on previously resolved references.
 */
module.exports.clearCache = function clearCache () {
  remoteCache = {};
};

/**
 * Returns whether or not the object represents a JSON Reference.
 *
 * @param {object|string} [obj] - The object to check
 *
 * @returns {boolean} true if the argument is an object and its $ref property is a string and false otherwise
 */
var isJsonReference = module.exports.isJsonReference = function isJsonReference (obj) {
  // TODO: Add check that the value is a valid JSON Pointer
  return _.isPlainObject(obj) && _.isString(obj.$ref);
};

/**
 * Takes an array of path segments and creates a JSON Pointer from it.
 *
 * @see {@link http://tools.ietf.org/html/rfc6901}
 *
 * @param {string[]} path - The path segments
 *
 * @returns {string} A JSON Pointer based on the path segments
 *
 * @throws Error if the arguments are missing or invalid
 */
var pathToPointer = module.exports.pathToPointer = function pathToPointer (path) {
  if (_.isUndefined(path)) {
    throw new Error('path is required');
  } else if (!_.isArray(path)) {
    throw new Error('path must be an array');
  }

  var ptr = '#';

  if (path.length > 0) {
    ptr += '/' + path.map(function (part) {
      return part.replace(/~/g, '~0').replace(/\//g, '~1');
    }).join('/');
  }

  return ptr;
};

/**
 * Find all JSON References in the document.
 *
 * @see {@link http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3}
 *
 * @param {object} json - The JSON document to find references in
 *
 * @returns {object} An object whose keys are JSON Pointers to the '$ref' node of the JSON Reference
 *
 * @throws Error if the arguments are missing or invalid
 */
var findRefs = module.exports.findRefs = function findRefs (json) {
  if (_.isUndefined(json)) {
    throw new Error('json is required');
  } else if (!_.isPlainObject(json)) {
    throw new Error('json must be an object');
  }

  return traverse(json).reduce(function (acc) {
    var val = this.node;

    if (this.key === '$ref' && isJsonReference(this.parent.node)) {
      acc[pathToPointer(this.path)] = val;
    }

    return acc;
  }, {});
};

/**
 * Returns whether or not the JSON Pointer is a remote reference.
 *
 * @param {string} ptr - The JSON Pointer
 *
 * @returns {boolean} true if the JSON Pointer is remote or false if not
 *
 * @throws Error if the arguments are missing or invalid
 */
var isRemotePointer = module.exports.isRemotePointer = function isRemotePointer (ptr) {
  if (_.isUndefined(ptr)) {
    throw new Error('ptr is required');
  } else if (!_.isString(ptr)) {
    throw new Error('ptr must be a string');
  }

  // We treat anything other than local, valid JSON Pointer values as remote
  return ptr !== '' && ptr.charAt(0) !== '#';
};

/**
 * Takes a JSON Reference and returns an array of path segments.
 *
 * @see {@link http://tools.ietf.org/html/rfc6901}
 *
 * @param {string} ptr - The JSON Pointer for the JSON Reference
 *
 * @returns {string[]} An array of path segments or the passed in string if it is a remote reference
 *
 * @throws Error if the arguments are missing or invalid
 */
var pathFromPointer = module.exports.pathFromPointer = function pathFromPointer (ptr) {
  if (_.isUndefined(ptr)) {
    throw new Error('ptr is required');
  } else if (!_.isString(ptr)) {
    throw new Error('ptr must be a string');
  }

  var path = [];
  var rootPaths = ['', '#', '#/'];

  if (isRemotePointer(ptr)) {
    path = ptr;
  } else {
    if (rootPaths.indexOf(ptr) === -1 && ptr.charAt(0) === '#') {
      path = ptr.substring(ptr.indexOf('/')).split('/').reduce(function (parts, part) {
        if (part !== '') {
          parts.push(part.replace(/~0/g, '~').replace(/~1/g, '/'));
        }

        return parts;
      }, []);
    }
  }

  return path;
};

function combineRefs (base, ref) {
  var basePath = pathFromPointer(base);

  if (isRemotePointer(ref)) {
    if (ref.indexOf('#') === -1) {
      ref = '#';
    } else {
      ref = ref.substring(ref.indexOf('#'));
    }
  }

  return pathToPointer(basePath.concat(pathFromPointer(ref))).replace(/\/\$ref/g, '');
}

function computeUrl (base, ref) {
  var isRelative = ref.charAt(0) !== '#' && ref.indexOf(':') === -1;
  var newLocation = [];
  var refSegments = (ref.indexOf('#') > -1 ? ref.split('#')[0] : ref).split('/');

  function segmentHandler (segment) {
    if (segment === '..') {
      newLocation.pop();
    } else if (segment !== '.') {
      newLocation.push(segment);
    }
  }

  // Remove trailing slash
  if (base && base.length > 1 && base[base.length - 1] === '/') {
    base = base.substring(0, base.length - 1);
  }

  // Normalize the base (when available)
  if (base) {
    base.split('#')[0].split('/').forEach(segmentHandler);
}

  if (isRelative) {
    // Add reference segments
    refSegments.forEach(segmentHandler);
  } else {
    newLocation = refSegments;
  }

  return newLocation.join('/');
}

function realResolveRefs (json, options, metadata) {
  var depth = _.isUndefined(options.depth) ? 1 : options.depth;
  var jsonT = traverse(json);

  function fixCirculars (rJsonT) {
    var circularPtrs = [];
    var scrubbed = rJsonT.map(function () {
      var ptr = pathToPointer(this.path);

      if (this.circular) {
        circularPtrs.push(ptr);

        metadata[combineRefs(ptr, '#')].circular = true;

        if (depth === 0) {
          this.update({});
        } else {
          this.update(traverse(this.node).map(function () {
            if (this.circular) {
              this.parent.update({});
            }
          }));
        }
      }
    });

    // Replace scrubbed circulars based on depth
    _.each(circularPtrs, function (ptr) {
      var depthPath = [];
      var path = pathFromPointer(ptr);
      var value = traverse(scrubbed).get(path);
      var i;

      for (i = 0; i < depth; i++) {
        depthPath.push.apply(depthPath, path);

        traverse(scrubbed).set(depthPath, _.cloneDeep(value));
      }
    });

    return scrubbed;
  }

  function replaceReference (ref, refPtr) {
    var refMetadataKey = combineRefs(refPtr, '#');
    var localRef = ref = ref.indexOf('#') === -1 ?
          '#' :
          ref.substring(ref.indexOf('#'));
    var localPath = pathFromPointer(localRef);
    var missing = !jsonT.has(localPath);
    var value = jsonT.get(localPath);
    var refPtrPath = pathFromPointer(refPtr);
    var parentPath = refPtrPath.slice(0, refPtrPath.length - 1);
    var refMetadata = metadata[refMetadataKey] || {
      ref: ref
    };

    if (!missing) {
      if (parentPath.length === 0) {
        // Self references are special
        if (jsonT.value === value) {
          value = {};

          refMetadata.circular = true;
        }

        jsonT.value = value;
      } else {
        if (jsonT.get(parentPath) === value) {
          value = {};

          refMetadata.circular = true;
        }

        jsonT.set(parentPath, value);
      }
    } else {
      refMetadata.missing = true;
    }

    metadata[refMetadataKey] = refMetadata;
  }

  // All references at this point should be local except missing/invalid references
  _.each(findRefs(json), function (ref, refPtr) {
    if (!isRemotePointer(ref)) {
      replaceReference(ref, refPtr);
    }
  });

  // Remove full locations from reference metadata
  if (!_.isUndefined(options.location)) {
    _.each(metadata, function (refMetadata) {
      var normalizedPtr = refMetadata.ref;

      // Remove the base
      normalizedPtr = normalizedPtr.replace(options.location, '');

      // Remove the / prefix
      if (normalizedPtr.charAt(0) === '/') {
        normalizedPtr = normalizedPtr.substring(1);
      }

      refMetadata.ref = normalizedPtr;
    });
  }

  // Fix circulars
  return {
    metadata: metadata,
    resolved: fixCirculars(jsonT)
  };
}

function resolveRemoteRefs (json, options, parentPtr, parents, metadata) {
  var allTasks = Promise.resolve();
  var jsonT = traverse(json);

  function replaceRemoteRef (refPtr, ptr, remoteLocation, remotePtr, resolved) {
    var normalizedPtr = remoteLocation + (remotePtr === '#' ? '' : remotePtr);
    var refMetadataKey = combineRefs(parentPtr, refPtr);
    var refMetadata = metadata[refMetadataKey] || {};
    var refPath = pathFromPointer(refPtr);
    var value;

    if (_.isUndefined(resolved)) {
      refMetadata.circular = true;

      value = parents[remoteLocation].ref;
    } else {
      value = traverse(resolved).get(pathFromPointer(remotePtr));

      // If the value is a reference, replace the reference value.  Otherwise, replace the reference.
      if (value.$ref) {
        value = value.$ref;
      } else {
        refPath.pop();
      }
    }

    // Collapse self references
    if (refPath.length === 0) {
      jsonT.value = value;
    } else {
      jsonT.set(refPath, value);
    }

    refMetadata.ref = normalizedPtr;

    metadata[refMetadataKey] = refMetadata;
  }

  function resolver () {
    return {
      metadata: metadata,
      resolved: jsonT.value
    };
  }

  _.each(findRefs(json), function (ptr, refPtr) {
    if (isRemotePointer(ptr)) {
      allTasks = allTasks.then(function () {
        var remoteLocation = computeUrl(options.location, ptr);
        var refParts = ptr.split('#');
        var hash = '#' + (refParts[1] || '');

        if (_.isUndefined(parents[remoteLocation])) {
          return getRemoteJson(remoteLocation, options)
            .then(function (remoteJson) {
              return remoteJson;
            }, function (err) {
              return err;
            })
            .then(function (response) {
              var refBase = refParts[0];
              var rOptions = _.cloneDeep(options);
              var newParentPtr = combineRefs(parentPtr, refPtr);

              // Remove the last path segment
              refBase = refBase.substring(0, refBase.lastIndexOf('/') + 1);

              // Update the recursive location
              rOptions.location = computeUrl(options.location, refBase);

              // Record the parent
              parents[remoteLocation] = {
                ref: parentPtr
              };

              if (_.isError(response)) {
                metadata[newParentPtr] = {
                  err: response,
                  missing: true,
                  ref: ptr
                };
              } else {
                // Resolve remote references
                return resolveRemoteRefs(response, rOptions, newParentPtr, parents, metadata)
                  .then(function (rMetadata) {
                    delete parents[remoteLocation];

                    replaceRemoteRef(refPtr, ptr, remoteLocation, hash, rMetadata.resolved);
                  });
              }
            });
        } else {
          // This is a circular reference
          replaceRemoteRef(refPtr, ptr, remoteLocation, hash);
        }
      });
    }
  });

  allTasks = allTasks.then(resolver, resolver);

  return allTasks;
}

/**
 * Takes a JSON document, resolves all JSON References and returns a fully resolved equivalent.
 *
 * If the document has no JSON References, the passed in document is returned untouched.  If there are references to be
 * resolved, the returned document is cloned and returned fully resolved.  The original document is untouched.
 *
 * @param {object} json - The JSON  document having zero or more JSON References
 * @param {object} [options] - The options (All options are passed down to whitlockjc/path-loader)
 * @param {number} [options.depth] - The depth to resolve circular references
 * @param {string} [options.location] - The location to which relative references should be resolved
 * @param {processContentCallback} [options.processContent] - The callback used to process a reference's content
 * @param {resultCallback} [done] - The result callback
 *
 * @throws Error if the arguments are missing or invalid
 *
 * @returns {Promise} The promise
 */
module.exports.resolveRefs = function resolveRefs (json, options, done) {
  var allTasks = Promise.resolve();

  if (arguments.length === 2) {
    if (_.isFunction(options)) {
      done = options;
      options = {};
    }
  }

  if (_.isUndefined(options)) {
    options = {};
  }

  allTasks = allTasks.then(function () {
    if (_.isUndefined(json)) {
      throw new Error('json is required');
    } else if (!_.isPlainObject(json)) {
      throw new Error('json must be an object');
    } else if (!_.isPlainObject(options)) {
      throw new Error('options must be an object');
    } else if (!_.isUndefined(done) && !_.isFunction(done)) {
      throw new Error('done must be a function');
    }

    // Validate the options (This option does not apply to )
    if (!_.isUndefined(options.processContent) && !_.isFunction(options.processContent)) {
      throw new Error('options.processContent must be a function');
    } else if (!_.isUndefined(options.prepareRequest) && !_.isFunction(options.prepareRequest)) {
      throw new Error('options.prepareRequest must be a function');
    } else if (!_.isUndefined(options.location) && !_.isString(options.location)) {
      throw new Error('options.location must be a string');
    } else if (!_.isUndefined(options.depth) && !_.isNumber(options.depth)) {
      throw new Error('options.depth must be a number');
    } else if (!_.isUndefined(options.depth) && options.depth < 0) {
      throw new Error('options.depth must be greater or equal to zero');
    }
  });

  // Clone the inputs so we do not alter them
  json = traverse(json).clone();
  options = traverse(options).clone();

  allTasks = allTasks
    .then(function () {
      return resolveRemoteRefs(json, options, '#', {}, {});
    })
    .then(function (metadata) {
      return realResolveRefs(metadata.resolved, options, metadata.metadata);
    });

  // Use the callback if provided and it is a function
  if (!_.isUndefined(done) && _.isFunction(done)) {
    allTasks = allTasks
      .then(function (results) {
        done(undefined, results.resolved, results.metadata);
      }, function (err) {
        done(err);
      });
  }

  return allTasks;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/utils":2,"native-promise-only":3}],2:[function(require,module,exports){
(function (global){
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

// This is a simple wrapper for Lodash functions but using simple ES5 and existing required dependencies
// (cloneDeep uses traverse for example).  The reason for this was a much smaller file size.  All exported functions
// match map to a lodash equivalent.

var traverse = (typeof window !== "undefined" ? window.traverse : typeof global !== "undefined" ? global.traverse : null);

function isType (obj, type) {
  return Object.prototype.toString.call(obj) === '[object ' + type + ']';
}

module.exports.cloneDeep = function (obj) {
  return traverse(obj).clone();
};

var isArray = module.exports.isArray = function (obj) {
  return isType(obj, 'Array');
};

module.exports.isError = function (obj) {
  return isType(obj, 'Error');
};

module.exports.isFunction = function (obj) {
  return isType(obj, 'Function');
};

module.exports.isNumber = function (obj) {
  return isType(obj, 'Number');
};

var isPlainObject = module.exports.isPlainObject = function (obj) {
  return isType(obj, 'Object');
};

module.exports.isString = function (obj) {
  return isType(obj, 'String');
};

module.exports.isUndefined = function (obj) {
  // Commented out due to PhantomJS bug (https://github.com/ariya/phantomjs/issues/11722)
  // return isType(obj, 'Undefined');
  return typeof obj === 'undefined';
};

module.exports.each = function (source, handler) {
  if (isArray(source)) {
    source.forEach(handler);
  } else if (isPlainObject(source)) {
    Object.keys(source).forEach(function (key) {
      handler(source[key], key);
    });
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
(function (global){
/*! Native Promise Only
    v0.8.0-a (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
!function(t,n,e){n[t]=n[t]||e(),"undefined"!=typeof module&&module.exports?module.exports=n[t]:"function"==typeof define&&define.amd&&define(function(){return n[t]})}("Promise","undefined"!=typeof global?global:this,function(){"use strict";function t(t,n){l.add(t,n),h||(h=y(l.drain))}function n(t){var n,e=typeof t;return null==t||"object"!=e&&"function"!=e||(n=t.then),"function"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError("Promise-chain cycle")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r))}catch(c){o.reject(c)}}function r(o){var c,u=this;if(!u.triggered){u.triggered=!0,u.def&&(u=u.def);try{(c=n(o))?t(function(){var t=new f(u);try{c.call(o,function(){r.apply(t,arguments)},function(){i.apply(t,arguments)})}catch(n){i.call(t,n)}}):(u.msg=o,u.state=1,u.chain.length>0&&t(e,u))}catch(a){i.call(new f(u),a)}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o))}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t)},o)}(r)}function f(t){this.def=t,this.triggered=!1}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function a(n){if("function"!=typeof n)throw TypeError("Not a function");if(0!==this.__NPO__)throw TypeError("Not a promise");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:"function"==typeof n?n:!0,failure:"function"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if("function"!=typeof t||"function"!=typeof n)throw TypeError("Not a function");i.resolve=t,i.reject=n}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this["catch"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t)},function(t){i.call(o,t)})}catch(c){i.call(o,c)}}var s,h,l,p=Object.prototype.toString,y="undefined"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},"x",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})}}catch(d){s=function(t,n,e){return t[n]=e,t}}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0}var n,e,o;return{add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next}}}();var g=s({},"constructor",a,!1);return a.prototype=g,s(g,"__NPO__",0,!1),s(a,"resolve",function(t){var n=this;return t&&"object"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");n(t)})}),s(a,"reject",function(t){return new this(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");e(t)})}),s(a,"all",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):0===t.length?n.resolve([]):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i)},o)})}),s(a,"race",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");c(n,t,function(t,n){e(n)},o)})}),a});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsImxpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9uYXRpdmUtcHJvbWlzZS1vbmx5L25wby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKZXJlbXkgV2hpdGxvY2tcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTG9hZCBwcm9taXNlcyBwb2x5ZmlsbCBpZiBuZWNlc3NhcnlcbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgcmVxdWlyZSgnbmF0aXZlLXByb21pc2Utb25seScpO1xufVxuXG52YXIgXyA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJyk7XG52YXIgcGF0aExvYWRlciA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlBhdGhMb2FkZXIgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlBhdGhMb2FkZXIgOiBudWxsKTtcbnZhciB0cmF2ZXJzZSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnRyYXZlcnNlIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC50cmF2ZXJzZSA6IG51bGwpO1xuXG52YXIgcmVtb3RlQ2FjaGUgPSB7fTtcbnZhciBzdXBwb3J0ZWRTY2hlbWVzID0gWydmaWxlJywgJ2h0dHAnLCAnaHR0cHMnXTtcblxuLyoqXG4gKiBDYWxsYmFjayB1c2VkIGJ5IGFsbCBqc29uLXJlZnMgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7ZXJyb3J9IFtlcnJdIC0gVGhlIGVycm9yIGlmIHRoZXJlIGlzIGEgcHJvYmxlbVxuICogQHBhcmFtIHsqfSBbcmVzdWx0XSAtIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXG4gKlxuICogQGNhbGxiYWNrIHJlc3VsdENhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayB1c2VkIHRvIHByb3ZpZGUgYWNjZXNzIHRvIGFsdGVyaW5nIGEgcmVtb3RlIHJlcXVlc3QgcHJpb3IgdG8gdGhlIHJlcXVlc3QgYmVpbmcgbWFkZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVxIC0gVGhlIFN1cGVyYWdlbnQgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSBUaGUgcmVmZXJlbmNlIGJlaW5nIHJlc29sdmVkIChXaGVuIGFwcGxpY2FibGUpXG4gKlxuICogQGNhbGxiYWNrIHByZXBhcmVSZXF1ZXN0Q2FsbGJhY2tcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIHVzZWQgdG8gcHJvY2VzcyB0aGUgY29udGVudCBvZiBhIHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIFRoZSBjb250ZW50IGxvYWRlZCBmcm9tIHRoZSBmaWxlL1VSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiAtIFRoZSByZWZlcmVuY2Ugc3RyaW5nIChXaGVuIGFwcGxpY2FibGUpXG4gKiBAcGFyYW0ge29iamVjdH0gW3Jlc10gLSBUaGUgU3VwZXJhZ2VudCByZXNwb25zZSBvYmplY3QgKEZvciByZW1vdGUgVVJMIHJlcXVlc3RzIG9ubHkpXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIEphdmFTY3JpcHQgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWZlcmVuY2VcbiAqXG4gKiBAY2FsbGJhY2sgcHJvY2Vzc0NvbnRlbnRDYWxsYmFja1xuICovXG5cbi8qIEludGVybmFsIEZ1bmN0aW9ucyAqL1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGVudCBhdCB0aGUgVVJMIGFuZCByZXR1cm5zIGl0cyBKU09OIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHJlc29sdmVSZWZzXG4gKlxuICogQHRocm93cyBFcnJvciBpZiB0aGVyZSBpcyBhIHByb2JsZW0gbWFraW5nIHRoZSByZXF1ZXN0IG9yIHRoZSBjb250ZW50IGlzIG5vdCBKU09OXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGdldFJlbW90ZUpzb24gKHVybCwgb3B0aW9ucykge1xuICB2YXIganNvbiA9IHJlbW90ZUNhY2hlW3VybF07XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB2YXIgc2NoZW1lID0gdXJsLmluZGV4T2YoJzonKSA9PT0gLTEgPyB1bmRlZmluZWQgOiB1cmwuc3BsaXQoJzonKVswXTtcblxuICBpZiAoIV8uaXNVbmRlZmluZWQoanNvbikpIHtcbiAgICBhbGxUYXNrcyA9IGFsbFRhc2tzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc3VwcG9ydGVkU2NoZW1lcy5pbmRleE9mKHNjaGVtZSkgPT09IC0xICYmICFfLmlzVW5kZWZpbmVkKHNjaGVtZSkpIHtcbiAgICBhbGxUYXNrcyA9IGFsbFRhc2tzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcmVtb3RlIHJlZmVyZW5jZSBzY2hlbWU6ICcgKyBzY2hlbWUpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhbGxUYXNrcyA9IHBhdGhMb2FkZXIubG9hZCh1cmwsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQpIHtcbiAgICAgIGFsbFRhc2tzID0gYWxsVGFza3MudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wcm9jZXNzQ29udGVudChjb250ZW50LCB1cmwpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbFRhc2tzID0gYWxsVGFza3MudGhlbihKU09OLnBhcnNlKTtcbiAgICB9XG5cbiAgICBhbGxUYXNrcy50aGVuKGZ1bmN0aW9uIChuSnNvbikge1xuICAgICAgcmVtb3RlQ2FjaGVbdXJsXSA9IG5Kc29uO1xuXG4gICAgICByZXR1cm4gbkpzb247XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYWxsVGFza3M7XG59XG5cbi8qIEV4cG9ydGVkIEZ1bmN0aW9ucyAqL1xuXG4vKipcbiAqIENsZWFycyB0aGUgaW50ZXJuYWwgY2FjaGUgb2YgdXJsIC0+IEphdmFTY3JpcHQgb2JqZWN0IG1hcHBpbmdzIGJhc2VkIG9uIHByZXZpb3VzbHkgcmVzb2x2ZWQgcmVmZXJlbmNlcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICByZW1vdGVDYWNoZSA9IHt9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgcmVwcmVzZW50cyBhIEpTT04gUmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29ial0gLSBUaGUgb2JqZWN0IHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgaXRzICRyZWYgcHJvcGVydHkgaXMgYSBzdHJpbmcgYW5kIGZhbHNlIG90aGVyd2lzZVxuICovXG52YXIgaXNKc29uUmVmZXJlbmNlID0gbW9kdWxlLmV4cG9ydHMuaXNKc29uUmVmZXJlbmNlID0gZnVuY3Rpb24gaXNKc29uUmVmZXJlbmNlIChvYmopIHtcbiAgLy8gVE9ETzogQWRkIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgSlNPTiBQb2ludGVyXG4gIHJldHVybiBfLmlzUGxhaW5PYmplY3Qob2JqKSAmJiBfLmlzU3RyaW5nKG9iai4kcmVmKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cyBhbmQgY3JlYXRlcyBhIEpTT04gUG9pbnRlciBmcm9tIGl0LlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDF9XG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCAtIFRoZSBwYXRoIHNlZ21lbnRzXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQSBKU09OIFBvaW50ZXIgYmFzZWQgb24gdGhlIHBhdGggc2VnbWVudHNcbiAqXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBhcmd1bWVudHMgYXJlIG1pc3Npbmcgb3IgaW52YWxpZFxuICovXG52YXIgcGF0aFRvUG9pbnRlciA9IG1vZHVsZS5leHBvcnRzLnBhdGhUb1BvaW50ZXIgPSBmdW5jdGlvbiBwYXRoVG9Qb2ludGVyIChwYXRoKSB7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXRoIGlzIHJlcXVpcmVkJyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNBcnJheShwYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICB2YXIgcHRyID0gJyMnO1xuXG4gIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICBwdHIgKz0gJy8nICsgcGF0aC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIHJldHVybiBwYXJ0LnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuICAgIH0pLmpvaW4oJy8nKTtcbiAgfVxuXG4gIHJldHVybiBwdHI7XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIEpTT04gUmVmZXJlbmNlcyBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMyNzZWN0aW9uLTN9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUgSlNPTiBkb2N1bWVudCB0byBmaW5kIHJlZmVyZW5jZXMgaW5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgSlNPTiBQb2ludGVycyB0byB0aGUgJyRyZWYnIG5vZGUgb2YgdGhlIEpTT04gUmVmZXJlbmNlXG4gKlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXJndW1lbnRzIGFyZSBtaXNzaW5nIG9yIGludmFsaWRcbiAqL1xudmFyIGZpbmRSZWZzID0gbW9kdWxlLmV4cG9ydHMuZmluZFJlZnMgPSBmdW5jdGlvbiBmaW5kUmVmcyAoanNvbikge1xuICBpZiAoXy5pc1VuZGVmaW5lZChqc29uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignanNvbiBpcyByZXF1aXJlZCcpO1xuICB9IGVsc2UgaWYgKCFfLmlzUGxhaW5PYmplY3QoanNvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2pzb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZShqc29uKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYykge1xuICAgIHZhciB2YWwgPSB0aGlzLm5vZGU7XG5cbiAgICBpZiAodGhpcy5rZXkgPT09ICckcmVmJyAmJiBpc0pzb25SZWZlcmVuY2UodGhpcy5wYXJlbnQubm9kZSkpIHtcbiAgICAgIGFjY1twYXRoVG9Qb2ludGVyKHRoaXMucGF0aCldID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgSlNPTiBQb2ludGVyIGlzIGEgcmVtb3RlIHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHRyIC0gVGhlIEpTT04gUG9pbnRlclxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBKU09OIFBvaW50ZXIgaXMgcmVtb3RlIG9yIGZhbHNlIGlmIG5vdFxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFyZ3VtZW50cyBhcmUgbWlzc2luZyBvciBpbnZhbGlkXG4gKi9cbnZhciBpc1JlbW90ZVBvaW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5pc1JlbW90ZVBvaW50ZXIgPSBmdW5jdGlvbiBpc1JlbW90ZVBvaW50ZXIgKHB0cikge1xuICBpZiAoXy5pc1VuZGVmaW5lZChwdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgaXMgcmVxdWlyZWQnKTtcbiAgfSBlbHNlIGlmICghXy5pc1N0cmluZyhwdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgLy8gV2UgdHJlYXQgYW55dGhpbmcgb3RoZXIgdGhhbiBsb2NhbCwgdmFsaWQgSlNPTiBQb2ludGVyIHZhbHVlcyBhcyByZW1vdGVcbiAgcmV0dXJuIHB0ciAhPT0gJycgJiYgcHRyLmNoYXJBdCgwKSAhPT0gJyMnO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIEpTT04gUmVmZXJlbmNlIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHRyIC0gVGhlIEpTT04gUG9pbnRlciBmb3IgdGhlIEpTT04gUmVmZXJlbmNlXG4gKlxuICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIG9yIHRoZSBwYXNzZWQgaW4gc3RyaW5nIGlmIGl0IGlzIGEgcmVtb3RlIHJlZmVyZW5jZVxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFyZ3VtZW50cyBhcmUgbWlzc2luZyBvciBpbnZhbGlkXG4gKi9cbnZhciBwYXRoRnJvbVBvaW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5wYXRoRnJvbVBvaW50ZXIgPSBmdW5jdGlvbiBwYXRoRnJvbVBvaW50ZXIgKHB0cikge1xuICBpZiAoXy5pc1VuZGVmaW5lZChwdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgaXMgcmVxdWlyZWQnKTtcbiAgfSBlbHNlIGlmICghXy5pc1N0cmluZyhwdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIHJvb3RQYXRocyA9IFsnJywgJyMnLCAnIy8nXTtcblxuICBpZiAoaXNSZW1vdGVQb2ludGVyKHB0cikpIHtcbiAgICBwYXRoID0gcHRyO1xuICB9IGVsc2Uge1xuICAgIGlmIChyb290UGF0aHMuaW5kZXhPZihwdHIpID09PSAtMSAmJiBwdHIuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIHBhdGggPSBwdHIuc3Vic3RyaW5nKHB0ci5pbmRleE9mKCcvJykpLnNwbGl0KCcvJykucmVkdWNlKGZ1bmN0aW9uIChwYXJ0cywgcGFydCkge1xuICAgICAgICBpZiAocGFydCAhPT0gJycpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQucmVwbGFjZSgvfjAvZywgJ34nKS5yZXBsYWNlKC9+MS9nLCAnLycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgIH0sIFtdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn07XG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWZzIChiYXNlLCByZWYpIHtcbiAgdmFyIGJhc2VQYXRoID0gcGF0aEZyb21Qb2ludGVyKGJhc2UpO1xuXG4gIGlmIChpc1JlbW90ZVBvaW50ZXIocmVmKSkge1xuICAgIGlmIChyZWYuaW5kZXhPZignIycpID09PSAtMSkge1xuICAgICAgcmVmID0gJyMnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSByZWYuc3Vic3RyaW5nKHJlZi5pbmRleE9mKCcjJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoVG9Qb2ludGVyKGJhc2VQYXRoLmNvbmNhdChwYXRoRnJvbVBvaW50ZXIocmVmKSkpLnJlcGxhY2UoL1xcL1xcJHJlZi9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVVcmwgKGJhc2UsIHJlZikge1xuICB2YXIgaXNSZWxhdGl2ZSA9IHJlZi5jaGFyQXQoMCkgIT09ICcjJyAmJiByZWYuaW5kZXhPZignOicpID09PSAtMTtcbiAgdmFyIG5ld0xvY2F0aW9uID0gW107XG4gIHZhciByZWZTZWdtZW50cyA9IChyZWYuaW5kZXhPZignIycpID4gLTEgPyByZWYuc3BsaXQoJyMnKVswXSA6IHJlZikuc3BsaXQoJy8nKTtcblxuICBmdW5jdGlvbiBzZWdtZW50SGFuZGxlciAoc2VnbWVudCkge1xuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICBuZXdMb2NhdGlvbi5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgbmV3TG9jYXRpb24ucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgaWYgKGJhc2UgJiYgYmFzZS5sZW5ndGggPiAxICYmIGJhc2VbYmFzZS5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgYmFzZSA9IGJhc2Uuc3Vic3RyaW5nKDAsIGJhc2UubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgdGhlIGJhc2UgKHdoZW4gYXZhaWxhYmxlKVxuICBpZiAoYmFzZSkge1xuICAgIGJhc2Uuc3BsaXQoJyMnKVswXS5zcGxpdCgnLycpLmZvckVhY2goc2VnbWVudEhhbmRsZXIpO1xufVxuXG4gIGlmIChpc1JlbGF0aXZlKSB7XG4gICAgLy8gQWRkIHJlZmVyZW5jZSBzZWdtZW50c1xuICAgIHJlZlNlZ21lbnRzLmZvckVhY2goc2VnbWVudEhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIG5ld0xvY2F0aW9uID0gcmVmU2VnbWVudHM7XG4gIH1cblxuICByZXR1cm4gbmV3TG9jYXRpb24uam9pbignLycpO1xufVxuXG5mdW5jdGlvbiByZWFsUmVzb2x2ZVJlZnMgKGpzb24sIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIHZhciBkZXB0aCA9IF8uaXNVbmRlZmluZWQob3B0aW9ucy5kZXB0aCkgPyAxIDogb3B0aW9ucy5kZXB0aDtcbiAgdmFyIGpzb25UID0gdHJhdmVyc2UoanNvbik7XG5cbiAgZnVuY3Rpb24gZml4Q2lyY3VsYXJzIChySnNvblQpIHtcbiAgICB2YXIgY2lyY3VsYXJQdHJzID0gW107XG4gICAgdmFyIHNjcnViYmVkID0gckpzb25ULm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHRyID0gcGF0aFRvUG9pbnRlcih0aGlzLnBhdGgpO1xuXG4gICAgICBpZiAodGhpcy5jaXJjdWxhcikge1xuICAgICAgICBjaXJjdWxhclB0cnMucHVzaChwdHIpO1xuXG4gICAgICAgIG1ldGFkYXRhW2NvbWJpbmVSZWZzKHB0ciwgJyMnKV0uY2lyY3VsYXIgPSB0cnVlO1xuXG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlKHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSh0cmF2ZXJzZSh0aGlzLm5vZGUpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaXJjdWxhcikge1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudC51cGRhdGUoe30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVwbGFjZSBzY3J1YmJlZCBjaXJjdWxhcnMgYmFzZWQgb24gZGVwdGhcbiAgICBfLmVhY2goY2lyY3VsYXJQdHJzLCBmdW5jdGlvbiAocHRyKSB7XG4gICAgICB2YXIgZGVwdGhQYXRoID0gW107XG4gICAgICB2YXIgcGF0aCA9IHBhdGhGcm9tUG9pbnRlcihwdHIpO1xuICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2Uoc2NydWJiZWQpLmdldChwYXRoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwdGg7IGkrKykge1xuICAgICAgICBkZXB0aFBhdGgucHVzaC5hcHBseShkZXB0aFBhdGgsIHBhdGgpO1xuXG4gICAgICAgIHRyYXZlcnNlKHNjcnViYmVkKS5zZXQoZGVwdGhQYXRoLCBfLmNsb25lRGVlcCh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNjcnViYmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZmVyZW5jZSAocmVmLCByZWZQdHIpIHtcbiAgICB2YXIgcmVmTWV0YWRhdGFLZXkgPSBjb21iaW5lUmVmcyhyZWZQdHIsICcjJyk7XG4gICAgdmFyIGxvY2FsUmVmID0gcmVmID0gcmVmLmluZGV4T2YoJyMnKSA9PT0gLTEgP1xuICAgICAgICAgICcjJyA6XG4gICAgICAgICAgcmVmLnN1YnN0cmluZyhyZWYuaW5kZXhPZignIycpKTtcbiAgICB2YXIgbG9jYWxQYXRoID0gcGF0aEZyb21Qb2ludGVyKGxvY2FsUmVmKTtcbiAgICB2YXIgbWlzc2luZyA9ICFqc29uVC5oYXMobG9jYWxQYXRoKTtcbiAgICB2YXIgdmFsdWUgPSBqc29uVC5nZXQobG9jYWxQYXRoKTtcbiAgICB2YXIgcmVmUHRyUGF0aCA9IHBhdGhGcm9tUG9pbnRlcihyZWZQdHIpO1xuICAgIHZhciBwYXJlbnRQYXRoID0gcmVmUHRyUGF0aC5zbGljZSgwLCByZWZQdHJQYXRoLmxlbmd0aCAtIDEpO1xuICAgIHZhciByZWZNZXRhZGF0YSA9IG1ldGFkYXRhW3JlZk1ldGFkYXRhS2V5XSB8fCB7XG4gICAgICByZWY6IHJlZlxuICAgIH07XG5cbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIGlmIChwYXJlbnRQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBTZWxmIHJlZmVyZW5jZXMgYXJlIHNwZWNpYWxcbiAgICAgICAgaWYgKGpzb25ULnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0ge307XG5cbiAgICAgICAgICByZWZNZXRhZGF0YS5jaXJjdWxhciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBqc29uVC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGpzb25ULmdldChwYXJlbnRQYXRoKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHt9O1xuXG4gICAgICAgICAgcmVmTWV0YWRhdGEuY2lyY3VsYXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAganNvblQuc2V0KHBhcmVudFBhdGgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmTWV0YWRhdGEubWlzc2luZyA9IHRydWU7XG4gICAgfVxuXG4gICAgbWV0YWRhdGFbcmVmTWV0YWRhdGFLZXldID0gcmVmTWV0YWRhdGE7XG4gIH1cblxuICAvLyBBbGwgcmVmZXJlbmNlcyBhdCB0aGlzIHBvaW50IHNob3VsZCBiZSBsb2NhbCBleGNlcHQgbWlzc2luZy9pbnZhbGlkIHJlZmVyZW5jZXNcbiAgXy5lYWNoKGZpbmRSZWZzKGpzb24pLCBmdW5jdGlvbiAocmVmLCByZWZQdHIpIHtcbiAgICBpZiAoIWlzUmVtb3RlUG9pbnRlcihyZWYpKSB7XG4gICAgICByZXBsYWNlUmVmZXJlbmNlKHJlZiwgcmVmUHRyKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJlbW92ZSBmdWxsIGxvY2F0aW9ucyBmcm9tIHJlZmVyZW5jZSBtZXRhZGF0YVxuICBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5sb2NhdGlvbikpIHtcbiAgICBfLmVhY2gobWV0YWRhdGEsIGZ1bmN0aW9uIChyZWZNZXRhZGF0YSkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWRQdHIgPSByZWZNZXRhZGF0YS5yZWY7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgYmFzZVxuICAgICAgbm9ybWFsaXplZFB0ciA9IG5vcm1hbGl6ZWRQdHIucmVwbGFjZShvcHRpb25zLmxvY2F0aW9uLCAnJyk7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgLyBwcmVmaXhcbiAgICAgIGlmIChub3JtYWxpemVkUHRyLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRQdHIgPSBub3JtYWxpemVkUHRyLnN1YnN0cmluZygxKTtcbiAgICAgIH1cblxuICAgICAgcmVmTWV0YWRhdGEucmVmID0gbm9ybWFsaXplZFB0cjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpeCBjaXJjdWxhcnNcbiAgcmV0dXJuIHtcbiAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgcmVzb2x2ZWQ6IGZpeENpcmN1bGFycyhqc29uVClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlbW90ZVJlZnMgKGpzb24sIG9wdGlvbnMsIHBhcmVudFB0ciwgcGFyZW50cywgbWV0YWRhdGEpIHtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHZhciBqc29uVCA9IHRyYXZlcnNlKGpzb24pO1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZW1vdGVSZWYgKHJlZlB0ciwgcHRyLCByZW1vdGVMb2NhdGlvbiwgcmVtb3RlUHRyLCByZXNvbHZlZCkge1xuICAgIHZhciBub3JtYWxpemVkUHRyID0gcmVtb3RlTG9jYXRpb24gKyAocmVtb3RlUHRyID09PSAnIycgPyAnJyA6IHJlbW90ZVB0cik7XG4gICAgdmFyIHJlZk1ldGFkYXRhS2V5ID0gY29tYmluZVJlZnMocGFyZW50UHRyLCByZWZQdHIpO1xuICAgIHZhciByZWZNZXRhZGF0YSA9IG1ldGFkYXRhW3JlZk1ldGFkYXRhS2V5XSB8fCB7fTtcbiAgICB2YXIgcmVmUGF0aCA9IHBhdGhGcm9tUG9pbnRlcihyZWZQdHIpO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHJlc29sdmVkKSkge1xuICAgICAgcmVmTWV0YWRhdGEuY2lyY3VsYXIgPSB0cnVlO1xuXG4gICAgICB2YWx1ZSA9IHBhcmVudHNbcmVtb3RlTG9jYXRpb25dLnJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB0cmF2ZXJzZShyZXNvbHZlZCkuZ2V0KHBhdGhGcm9tUG9pbnRlcihyZW1vdGVQdHIpKTtcblxuICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgcmVmZXJlbmNlLCByZXBsYWNlIHRoZSByZWZlcmVuY2UgdmFsdWUuICBPdGhlcndpc2UsIHJlcGxhY2UgdGhlIHJlZmVyZW5jZS5cbiAgICAgIGlmICh2YWx1ZS4kcmVmKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuJHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZlBhdGgucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29sbGFwc2Ugc2VsZiByZWZlcmVuY2VzXG4gICAgaWYgKHJlZlBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICBqc29uVC52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBqc29uVC5zZXQocmVmUGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJlZk1ldGFkYXRhLnJlZiA9IG5vcm1hbGl6ZWRQdHI7XG5cbiAgICBtZXRhZGF0YVtyZWZNZXRhZGF0YUtleV0gPSByZWZNZXRhZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVyICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgcmVzb2x2ZWQ6IGpzb25ULnZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIF8uZWFjaChmaW5kUmVmcyhqc29uKSwgZnVuY3Rpb24gKHB0ciwgcmVmUHRyKSB7XG4gICAgaWYgKGlzUmVtb3RlUG9pbnRlcihwdHIpKSB7XG4gICAgICBhbGxUYXNrcyA9IGFsbFRhc2tzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVtb3RlTG9jYXRpb24gPSBjb21wdXRlVXJsKG9wdGlvbnMubG9jYXRpb24sIHB0cik7XG4gICAgICAgIHZhciByZWZQYXJ0cyA9IHB0ci5zcGxpdCgnIycpO1xuICAgICAgICB2YXIgaGFzaCA9ICcjJyArIChyZWZQYXJ0c1sxXSB8fCAnJyk7XG5cbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyZW50c1tyZW1vdGVMb2NhdGlvbl0pKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFJlbW90ZUpzb24ocmVtb3RlTG9jYXRpb24sIG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVtb3RlSnNvbikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVtb3RlSnNvbjtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdmFyIHJlZkJhc2UgPSByZWZQYXJ0c1swXTtcbiAgICAgICAgICAgICAgdmFyIHJPcHRpb25zID0gXy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgICAgICAgICAgIHZhciBuZXdQYXJlbnRQdHIgPSBjb21iaW5lUmVmcyhwYXJlbnRQdHIsIHJlZlB0cik7XG5cbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IHBhdGggc2VnbWVudFxuICAgICAgICAgICAgICByZWZCYXNlID0gcmVmQmFzZS5zdWJzdHJpbmcoMCwgcmVmQmFzZS5sYXN0SW5kZXhPZignLycpICsgMSk7XG5cbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWN1cnNpdmUgbG9jYXRpb25cbiAgICAgICAgICAgICAgck9wdGlvbnMubG9jYXRpb24gPSBjb21wdXRlVXJsKG9wdGlvbnMubG9jYXRpb24sIHJlZkJhc2UpO1xuXG4gICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgcGFyZW50XG4gICAgICAgICAgICAgIHBhcmVudHNbcmVtb3RlTG9jYXRpb25dID0ge1xuICAgICAgICAgICAgICAgIHJlZjogcGFyZW50UHRyXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKF8uaXNFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVtuZXdQYXJlbnRQdHJdID0ge1xuICAgICAgICAgICAgICAgICAgZXJyOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIG1pc3Npbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICByZWY6IHB0clxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSByZW1vdGUgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlUmVtb3RlUmVmcyhyZXNwb25zZSwgck9wdGlvbnMsIG5ld1BhcmVudFB0ciwgcGFyZW50cywgbWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAock1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnRzW3JlbW90ZUxvY2F0aW9uXTtcblxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlUmVtb3RlUmVmKHJlZlB0ciwgcHRyLCByZW1vdGVMb2NhdGlvbiwgaGFzaCwgck1ldGFkYXRhLnJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgcmVwbGFjZVJlbW90ZVJlZihyZWZQdHIsIHB0ciwgcmVtb3RlTG9jYXRpb24sIGhhc2gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGFsbFRhc2tzID0gYWxsVGFza3MudGhlbihyZXNvbHZlciwgcmVzb2x2ZXIpO1xuXG4gIHJldHVybiBhbGxUYXNrcztcbn1cblxuLyoqXG4gKiBUYWtlcyBhIEpTT04gZG9jdW1lbnQsIHJlc29sdmVzIGFsbCBKU09OIFJlZmVyZW5jZXMgYW5kIHJldHVybnMgYSBmdWxseSByZXNvbHZlZCBlcXVpdmFsZW50LlxuICpcbiAqIElmIHRoZSBkb2N1bWVudCBoYXMgbm8gSlNPTiBSZWZlcmVuY2VzLCB0aGUgcGFzc2VkIGluIGRvY3VtZW50IGlzIHJldHVybmVkIHVudG91Y2hlZC4gIElmIHRoZXJlIGFyZSByZWZlcmVuY2VzIHRvIGJlXG4gKiByZXNvbHZlZCwgdGhlIHJldHVybmVkIGRvY3VtZW50IGlzIGNsb25lZCBhbmQgcmV0dXJuZWQgZnVsbHkgcmVzb2x2ZWQuICBUaGUgb3JpZ2luYWwgZG9jdW1lbnQgaXMgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gIGRvY3VtZW50IGhhdmluZyB6ZXJvIG9yIG1vcmUgSlNPTiBSZWZlcmVuY2VzXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMgKEFsbCBvcHRpb25zIGFyZSBwYXNzZWQgZG93biB0byB3aGl0bG9ja2pjL3BhdGgtbG9hZGVyKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlcHRoXSAtIFRoZSBkZXB0aCB0byByZXNvbHZlIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhdGlvbl0gLSBUaGUgbG9jYXRpb24gdG8gd2hpY2ggcmVsYXRpdmUgcmVmZXJlbmNlcyBzaG91bGQgYmUgcmVzb2x2ZWRcbiAqIEBwYXJhbSB7cHJvY2Vzc0NvbnRlbnRDYWxsYmFja30gW29wdGlvbnMucHJvY2Vzc0NvbnRlbnRdIC0gVGhlIGNhbGxiYWNrIHVzZWQgdG8gcHJvY2VzcyBhIHJlZmVyZW5jZSdzIGNvbnRlbnRcbiAqIEBwYXJhbSB7cmVzdWx0Q2FsbGJhY2t9IFtkb25lXSAtIFRoZSByZXN1bHQgY2FsbGJhY2tcbiAqXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBhcmd1bWVudHMgYXJlIG1pc3Npbmcgb3IgaW52YWxpZFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZVxuICovXG5tb2R1bGUuZXhwb3J0cy5yZXNvbHZlUmVmcyA9IGZ1bmN0aW9uIHJlc29sdmVSZWZzIChqc29uLCBvcHRpb25zLCBkb25lKSB7XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICB9XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBhbGxUYXNrcyA9IGFsbFRhc2tzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGpzb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pzb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9IGVsc2UgaWYgKCFfLmlzUGxhaW5PYmplY3QoanNvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignanNvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChkb25lKSAmJiAhXy5pc0Z1bmN0aW9uKGRvbmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIG9wdGlvbnMgKFRoaXMgb3B0aW9uIGRvZXMgbm90IGFwcGx5IHRvIClcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5wcm9jZXNzQ29udGVudCkgJiYgIV8uaXNGdW5jdGlvbihvcHRpb25zLnByb2Nlc3NDb250ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnByb2Nlc3NDb250ZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5wcmVwYXJlUmVxdWVzdCkgJiYgIV8uaXNGdW5jdGlvbihvcHRpb25zLnByZXBhcmVSZXF1ZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnByZXBhcmVSZXF1ZXN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5sb2NhdGlvbikgJiYgIV8uaXNTdHJpbmcob3B0aW9ucy5sb2NhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5sb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLmRlcHRoKSAmJiAhXy5pc051bWJlcihvcHRpb25zLmRlcHRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLmRlcHRoIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMuZGVwdGgpICYmIG9wdGlvbnMuZGVwdGggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuZGVwdGggbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIHplcm8nKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENsb25lIHRoZSBpbnB1dHMgc28gd2UgZG8gbm90IGFsdGVyIHRoZW1cbiAganNvbiA9IHRyYXZlcnNlKGpzb24pLmNsb25lKCk7XG4gIG9wdGlvbnMgPSB0cmF2ZXJzZShvcHRpb25zKS5jbG9uZSgpO1xuXG4gIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVJlbW90ZVJlZnMoanNvbiwgb3B0aW9ucywgJyMnLCB7fSwge30pO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gcmVhbFJlc29sdmVSZWZzKG1ldGFkYXRhLnJlc29sdmVkLCBvcHRpb25zLCBtZXRhZGF0YS5tZXRhZGF0YSk7XG4gICAgfSk7XG5cbiAgLy8gVXNlIHRoZSBjYWxsYmFjayBpZiBwcm92aWRlZCBhbmQgaXQgaXMgYSBmdW5jdGlvblxuICBpZiAoIV8uaXNVbmRlZmluZWQoZG9uZSkgJiYgXy5pc0Z1bmN0aW9uKGRvbmUpKSB7XG4gICAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgZG9uZSh1bmRlZmluZWQsIHJlc3VsdHMucmVzb2x2ZWQsIHJlc3VsdHMubWV0YWRhdGEpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkb25lKGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhbGxUYXNrcztcbn07XG4iLCIvKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEplcmVteSBXaGl0bG9ja1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGlzIGEgc2ltcGxlIHdyYXBwZXIgZm9yIExvZGFzaCBmdW5jdGlvbnMgYnV0IHVzaW5nIHNpbXBsZSBFUzUgYW5kIGV4aXN0aW5nIHJlcXVpcmVkIGRlcGVuZGVuY2llc1xuLy8gKGNsb25lRGVlcCB1c2VzIHRyYXZlcnNlIGZvciBleGFtcGxlKS4gIFRoZSByZWFzb24gZm9yIHRoaXMgd2FzIGEgbXVjaCBzbWFsbGVyIGZpbGUgc2l6ZS4gIEFsbCBleHBvcnRlZCBmdW5jdGlvbnNcbi8vIG1hdGNoIG1hcCB0byBhIGxvZGFzaCBlcXVpdmFsZW50LlxuXG52YXIgdHJhdmVyc2UgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy50cmF2ZXJzZSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudHJhdmVyc2UgOiBudWxsKTtcblxuZnVuY3Rpb24gaXNUeXBlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbn1cblxubW9kdWxlLmV4cG9ydHMuY2xvbmVEZWVwID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHJhdmVyc2Uob2JqKS5jbG9uZSgpO1xufTtcblxudmFyIGlzQXJyYXkgPSBtb2R1bGUuZXhwb3J0cy5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gaXNUeXBlKG9iaiwgJ0FycmF5Jyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pc0Vycm9yID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gaXNUeXBlKG9iaiwgJ0Vycm9yJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gaXNUeXBlKG9iaiwgJ0Z1bmN0aW9uJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzVHlwZShvYmosICdOdW1iZXInKTtcbn07XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gbW9kdWxlLmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzVHlwZShvYmosICdPYmplY3QnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gaXNUeXBlKG9iaiwgJ1N0cmluZycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIC8vIENvbW1lbnRlZCBvdXQgZHVlIHRvIFBoYW50b21KUyBidWcgKGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExNzIyKVxuICAvLyByZXR1cm4gaXNUeXBlKG9iaiwgJ1VuZGVmaW5lZCcpO1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24gKHNvdXJjZSwgaGFuZGxlcikge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgc291cmNlLmZvckVhY2goaGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGhhbmRsZXIoc291cmNlW2tleV0sIGtleSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCIvKiEgTmF0aXZlIFByb21pc2UgT25seVxuICAgIHYwLjguMC1hIChjKSBLeWxlIFNpbXBzb25cbiAgICBNSVQgTGljZW5zZTogaHR0cDovL2dldGlmeS5taXQtbGljZW5zZS5vcmdcbiovXG4hZnVuY3Rpb24odCxuLGUpe25bdF09blt0XXx8ZSgpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPW5bdF06XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gblt0XX0pfShcIlByb21pc2VcIixcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDp0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0LG4pe2wuYWRkKHQsbiksaHx8KGg9eShsLmRyYWluKSl9ZnVuY3Rpb24gbih0KXt2YXIgbixlPXR5cGVvZiB0O3JldHVybiBudWxsPT10fHxcIm9iamVjdFwiIT1lJiZcImZ1bmN0aW9uXCIhPWV8fChuPXQudGhlbiksXCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOiExfWZ1bmN0aW9uIGUoKXtmb3IodmFyIHQ9MDt0PHRoaXMuY2hhaW4ubGVuZ3RoO3QrKylvKHRoaXMsMT09PXRoaXMuc3RhdGU/dGhpcy5jaGFpblt0XS5zdWNjZXNzOnRoaXMuY2hhaW5bdF0uZmFpbHVyZSx0aGlzLmNoYWluW3RdKTt0aGlzLmNoYWluLmxlbmd0aD0wfWZ1bmN0aW9uIG8odCxlLG8pe3ZhciByLGk7dHJ5e2U9PT0hMT9vLnJlamVjdCh0Lm1zZyk6KHI9ZT09PSEwP3QubXNnOmUuY2FsbCh2b2lkIDAsdC5tc2cpLHI9PT1vLnByb21pc2U/by5yZWplY3QoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk6KGk9bihyKSk/aS5jYWxsKHIsby5yZXNvbHZlLG8ucmVqZWN0KTpvLnJlc29sdmUocikpfWNhdGNoKGMpe28ucmVqZWN0KGMpfX1mdW5jdGlvbiByKG8pe3ZhciBjLHU9dGhpcztpZighdS50cmlnZ2VyZWQpe3UudHJpZ2dlcmVkPSEwLHUuZGVmJiYodT11LmRlZik7dHJ5eyhjPW4obykpP3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgZih1KTt0cnl7Yy5jYWxsKG8sZnVuY3Rpb24oKXtyLmFwcGx5KHQsYXJndW1lbnRzKX0sZnVuY3Rpb24oKXtpLmFwcGx5KHQsYXJndW1lbnRzKX0pfWNhdGNoKG4pe2kuY2FsbCh0LG4pfX0pOih1Lm1zZz1vLHUuc3RhdGU9MSx1LmNoYWluLmxlbmd0aD4wJiZ0KGUsdSkpfWNhdGNoKGEpe2kuY2FsbChuZXcgZih1KSxhKX19fWZ1bmN0aW9uIGkobil7dmFyIG89dGhpcztvLnRyaWdnZXJlZHx8KG8udHJpZ2dlcmVkPSEwLG8uZGVmJiYobz1vLmRlZiksby5tc2c9bixvLnN0YXRlPTIsby5jaGFpbi5sZW5ndGg+MCYmdChlLG8pKX1mdW5jdGlvbiBjKHQsbixlLG8pe2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKSFmdW5jdGlvbihyKXt0LnJlc29sdmUobltyXSkudGhlbihmdW5jdGlvbih0KXtlKHIsdCl9LG8pfShyKX1mdW5jdGlvbiBmKHQpe3RoaXMuZGVmPXQsdGhpcy50cmlnZ2VyZWQ9ITF9ZnVuY3Rpb24gdSh0KXt0aGlzLnByb21pc2U9dCx0aGlzLnN0YXRlPTAsdGhpcy50cmlnZ2VyZWQ9ITEsdGhpcy5jaGFpbj1bXSx0aGlzLm1zZz12b2lkIDB9ZnVuY3Rpb24gYShuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2lmKDAhPT10aGlzLl9fTlBPX18pdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTt0aGlzLl9fTlBPX189MTt2YXIgbz1uZXcgdSh0aGlzKTt0aGlzLnRoZW49ZnVuY3Rpb24obixyKXt2YXIgaT17c3VjY2VzczpcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246ITAsZmFpbHVyZTpcImZ1bmN0aW9uXCI9PXR5cGVvZiByP3I6ITF9O3JldHVybiBpLnByb21pc2U9bmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24odCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2kucmVzb2x2ZT10LGkucmVqZWN0PW59KSxvLmNoYWluLnB1c2goaSksMCE9PW8uc3RhdGUmJnQoZSxvKSxpLnByb21pc2V9LHRoaXNbXCJjYXRjaFwiXT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCx0KX07dHJ5e24uY2FsbCh2b2lkIDAsZnVuY3Rpb24odCl7ci5jYWxsKG8sdCl9LGZ1bmN0aW9uKHQpe2kuY2FsbChvLHQpfSl9Y2F0Y2goYyl7aS5jYWxsKG8sYyl9fXZhciBzLGgsbCxwPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcseT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0SW1tZWRpYXRlP2Z1bmN0aW9uKHQpe3JldHVybiBzZXRJbW1lZGlhdGUodCl9OnNldFRpbWVvdXQ7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInhcIix7fSkscz1mdW5jdGlvbih0LG4sZSxvKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6byE9PSExfSl9fWNhdGNoKGQpe3M9ZnVuY3Rpb24odCxuLGUpe3JldHVybiB0W25dPWUsdH19bD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxuKXt0aGlzLmZuPXQsdGhpcy5zZWxmPW4sdGhpcy5uZXh0PXZvaWQgMH12YXIgbixlLG87cmV0dXJue2FkZDpmdW5jdGlvbihyLGkpe289bmV3IHQocixpKSxlP2UubmV4dD1vOm49byxlPW8sbz12b2lkIDB9LGRyYWluOmZ1bmN0aW9uKCl7dmFyIHQ9bjtmb3Iobj1lPWg9dm9pZCAwO3Q7KXQuZm4uY2FsbCh0LnNlbGYpLHQ9dC5uZXh0fX19KCk7dmFyIGc9cyh7fSxcImNvbnN0cnVjdG9yXCIsYSwhMSk7cmV0dXJuIGEucHJvdG90eXBlPWcscyhnLFwiX19OUE9fX1wiLDAsITEpLHMoYSxcInJlc29sdmVcIixmdW5jdGlvbih0KXt2YXIgbj10aGlzO3JldHVybiB0JiZcIm9iamVjdFwiPT10eXBlb2YgdCYmMT09PXQuX19OUE9fXz90Om5ldyBuKGZ1bmN0aW9uKG4sZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbnx8XCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtuKHQpfSl9KSxzKGEsXCJyZWplY3RcIixmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24obixlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBufHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2UodCl9KX0pLHMoYSxcImFsbFwiLGZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiIT1wLmNhbGwodCk/bi5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTowPT09dC5sZW5ndGg/bi5yZXNvbHZlKFtdKTpuZXcgbihmdW5jdGlvbihlLG8pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG8pdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7dmFyIHI9dC5sZW5ndGgsaT1BcnJheShyKSxmPTA7YyhuLHQsZnVuY3Rpb24odCxuKXtpW3RdPW4sKytmPT09ciYmZShpKX0sbyl9KX0pLHMoYSxcInJhY2VcIixmdW5jdGlvbih0KXt2YXIgbj10aGlzO3JldHVyblwiW29iamVjdCBBcnJheV1cIiE9cC5jYWxsKHQpP24ucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk6bmV3IG4oZnVuY3Rpb24oZSxvKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBvKXRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO2Mobix0LGZ1bmN0aW9uKHQsbil7ZShuKX0sbyl9KX0pLGF9KTtcbiJdfQ==
